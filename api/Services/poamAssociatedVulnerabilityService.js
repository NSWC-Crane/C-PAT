/*
!##########################################################################
! CRANE PLAN OF ACTION AND MILESTONE AUTOMATION TOOL (C-PAT) SOFTWARE
! Use is governed by the Open Source Academic Research License Agreement
! contained in the LICENSE.MD file, which is part of this software package.
! BY USING OR MODIFYING THIS SOFTWARE, YOU ARE AGREEING TO THE TERMS AND
! CONDITIONS OF THE LICENSE.
!##########################################################################
*/

'use strict';
const config = require('../utils/config')
const dbUtils = require('./utils')
const mysql = require('mysql2')

async function withConnection(callback) {
    const connection = await dbUtils.pool.getConnection();
    try {
        return await callback(connection);
    } finally {
        await connection.release();
    }
}

exports.getRawAssociatedVulnsByPoam = async function getRawAssociatedVulnsByPoam(poamId) {
    try {
        if (!poamId) {
            return next({
                status: 400,
                errors: {
                    poamId: 'is required',
                }
            });
        }
        return await withConnection(async (connection) => {
            let sql = `
                SELECT GROUP_CONCAT(associatedVulnerability) as associatedVulnerabilities
                FROM cpat.poamassociatedvulnerabilities
                WHERE poamId = ?
                GROUP BY poamId
            `;
            let [rowVulnerabilities] = await connection.query(sql, [poamId]);
            return rowVulnerabilities.length > 0 ?
                rowVulnerabilities[0].associatedVulnerabilities || '' :
                '';
        });
    } catch (error) {
        return { error: error.message };
    }
}

exports.getPoamAssociatedVulnerabilitiesByPoam = async function getPoamAssociatedVulnerabilitiesByPoam(poamId) {
    try {
        if (!poamId) {
            return next({
                status: 400,
                errors: {
                    poamId: 'is required',
                }
            });
        }

        return await withConnection(async (connection) => {
            let sql = `
                SELECT t1.poamId, t1.associatedVulnerability, t2.status as poamStatus
                FROM cpat.poamassociatedvulnerabilities t1
                INNER JOIN cpat.poam t2 ON t1.poamId = t2.poamId
                WHERE t1.poamId = ?
                ORDER BY t1.associatedVulnerability DESC
            `;
            let [rowVulnerabilities] = await connection.query(sql, [poamId]);
            return rowVulnerabilities.map(row => ({
                poamId: row.poamId,
                associatedVulnerability: row.associatedVulnerability,
                poamStatus: row.poamStatus
            }));
        });
    } catch (error) {
        return { error: error.message };
    }
}

exports.postPoamAssociatedVulnerability = async function postPoamAssociatedVulnerability(req, res, next) {
    if (!req.body.poamId) {
        return next({
            status: 400,
            errors: {
                poamId: 'is required',
            }
        });
    } else if (!req.body.associatedVulnerability) {
        return next({
            status: 400,
            errors: {
                associatedVulnerability: 'is required',
            }
        });
    }

    try {
        return await withConnection(async (connection) => {
            let checkPoamSql = "SELECT poamId FROM cpat.poam WHERE poamId = ?";
            const [poamExists] = await connection.query(checkPoamSql, [req.body.poamId]);

            if (!poamExists.length) {
                return next({
                    status: 400,
                    errors: {
                        poamId: 'POAM does not exist',
                    }
                });
            }

            let sql_query = `INSERT INTO cpat.poamassociatedvulnerabilities (poamId, associatedVulnerability) 
                            VALUES (?, ?)`;
            await connection.query(sql_query, [
                req.body.poamId,
                req.body.associatedVulnerability
            ]);

            let action = `Associated vulnerability "${req.body.associatedVulnerability}" was added to the POAM.`;
            let logSql = "INSERT INTO cpat.poamlogs (poamId, action, userId) VALUES (?, ?, ?)";
            await connection.query(logSql, [req.body.poamId, action, req.userObject.userId]);

            let sql = `
                SELECT t1.poamId, t1.associatedVulnerability, t2.status as poamStatus
                FROM cpat.poamassociatedvulnerabilities t1
                INNER JOIN cpat.poam t2 ON t1.poamId = t2.poamId
                WHERE t1.poamId = ? AND t1.associatedVulnerability = ?
            `;
            let [rowVulnerability] = await connection.query(sql, [
                req.body.poamId,
                req.body.associatedVulnerability
            ]);
            return rowVulnerability[0];
        });
    } catch (error) {
        if (error.code === 'ER_DUP_ENTRY') {
            return await withConnection(async (connection) => {
                let fetchSql = `SELECT * FROM cpat.poamassociatedvulnerabilities 
                               WHERE poamId = ? AND associatedVulnerability = ?`;
                const [existingVuln] = await connection.query(fetchSql, [
                    req.body.poamId,
                    req.body.associatedVulnerability
                ]);
                return existingVuln[0];
            });
        }
        else {
            return { error: error.message };
        }
    }
}

exports.deletePoamAssociatedVulnerability = async function deletePoamAssociatedVulnerability(req, res, next) {
    if (!req.params.poamId) {
        return next({
            status: 400,
            errors: {
                poamId: 'is required',
            }
        });
    } else if (!req.params.associatedVulnerability) {
        return next({
            status: 400,
            errors: {
                associatedVulnerability: 'is required',
            }
        });
    }

    try {
        return await withConnection(async (connection) => {
            let action = `Associated vulnerability "${req.params.associatedVulnerability}" was removed from the POAM.`;
            let logSql = "INSERT INTO cpat.poamlogs (poamId, action, userId) VALUES (?, ?, ?)";
            await connection.query(logSql, [req.params.poamId, action, req.userObject.userId]);

            let sql = `DELETE FROM cpat.poamassociatedvulnerabilities 
                      WHERE poamId = ? AND associatedVulnerability = ?`;
            await connection.query(sql, [req.params.poamId, req.params.associatedVulnerability]);

            return {};
        });
    } catch (error) {
        return { error: error.message };
    }
}